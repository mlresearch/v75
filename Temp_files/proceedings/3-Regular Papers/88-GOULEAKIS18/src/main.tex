\documentclass[final,12pt]{colt2018}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
%\usepackage{geometry}
%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{soul}
%\usepackage{amssymb}
%\usepackage{graphicx}
%\usepackage{rotating}
%\usepackage{amsbsy}
%\usepackage{a4wide}
%\usepackage{graphicx,  ucs}
%\usepackage{float}
%\usepackage{tikz}
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}
%\usepackage{listings}
\usepackage{enumitem}
%\usepackage{times}
\usepackage{hyperref}
%\usepackage{multirow}
%\usepackage{array}
%\usepackage[compact]{titlesec}
%% These have been added at the request of the MIT Libraries, because
%% some PDF conversions mess up the ligatures.  -LB, 1/22/2014
%\usepackage{cmap}
%\usepackage[T1]{fontenc}
\usepackage{bm}
\usepackage{comment}

\title[Certified Computation from Unreliable Datasets]{Certified Computation from Unreliable Datasets}
\usepackage{times}



% Compact itemize and enumerate.  Note that they use the same counters
% and symbols as the usual itemize and enumerate environments.
\def\compactify{\itemsep=0pt \topsep=0pt \partopsep=0pt \parsep=0pt}
\let\latexusecounter=\usecounter
%\newenvironment{CompactItemize}
%  {\def\usecounter{\compactify\latexusecounter}
%   \begin{itemize}}
%  {\end{itemize}\let\usecounter=\latexusecounter}
\newenvironment{CompactEnumerate}
  {\def\usecounter{\compactify\latexusecounter}
   \begin{enumerate}}
  {\end{enumerate}\let\usecounter=\latexusecounter}
\newenvironment{Itemize}%
{\begin{itemize}%
\setlength{\itemsep}{0pt}%
\setlength{\topsep}{0pt}%
\setlength{\partopsep}{0 in}%
\setlength{\parskip}{0 pt}}%
{\end{itemize}}

\newenvironment{pproof}
{ \noindent \textit{Proof.}  }
{ \hfill \rule{1.5ex}{1.5ex} }

\newcommand{\Domain}{\mathcal{D}}
\newcommand{\Support}{\mathcal{X}}
\newcommand{\Set}{S_{\mathcal{X}}}


% paper specific commands
\newcommand{\Workers}{\mathcal{N}}
\newcommand{\Truth}{\mathcal{T}}
\newcommand{\xw}{\vec{x}_{\Workers}}
\newcommand{\xt}{\vec{x}_{\Truth}}
\newcommand{\xs}{\vec{x}_{S}}

\newcommand{\Pow}{\mathrm{Pow}}
\newcommand{\PPow}{\mathrm{pPow}}
\newcommand{\Expo}{\mathrm{Exp}}
\newcommand{\Exp}{\mathbb{E}}
\newcommand{\tl}{\textlatin}
\newcommand{\tg}{\textgreek}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\pos}{\text{pos}}
\newcommand{\argmax}{\text{argmax}}
%\newcommand{\ver}{\text{VER}}
\newcommand{\argmin}{\text{argmin}}
\newcommand{\Neg}{\text{Neg}}
\newcommand{\appr}[1]{\(#1\)-\tl{approximation}}
\newcommand{\apprf}[2]{\(\frac{#1}{#2}\)-\tl{approximation}}
\newcommand{\com}[1]{}

%\newcommand{\ham}{\mathcal{H}}
%
%\definecolor{myC}{rgb}{0, 255, 255}
%\definecolor{myY}{rgb}{204, 204, 0}
%\definecolor{myM}{rgb}{255, 0, 255}
%
%

\def\poly{\mathrm{poly}}
\def\eps{\varepsilon}
\def\union{\cup}
\def\bigunion{\bigcup}
\def\cut{\cap}

\def\floor#1{\mathop{\left\lfloor#1\right\rfloor}}
\def\ceil#1{\mathop{\left\lceil#1\right\rceil}}
\def\Prob{\mathbb{P}}
\def\Exp{\mathbb{E}}
\def\Alg{\textsc{Alg}}
\def\Sub{\textsc{Sub}}
\def\Cond{\textsc{Cond}}
\def\EP{\textsc{EP}}
\def\SE{\textsc{SE}}
\def\DV{\textsc{DV}}
\def\MAX{\textsc{Max}}
\def\ARGMAX{\textsc{ArgMax}}
\def\SUM{\textsc{Sum}}
\def\WCOND{\textsc{WCond}}
\def\DES{\textsc{DES}}
\def\TIME{\textsc{TIME}}
\def\SPACE{\textsc{SPACE}}
\def\PSPACE{\textsc{PSPACE}}
\def\PLS{\textsc{PLS}}
\def\PPA{\textsc{PPA}}
\def\PPP{\textsc{PPP}}
\def\PPAD{\textsc{PPAD}}
\def\PPADS{\textsc{PPADS}}
\def\CLS{\textsc{CLS}}
\def\P{\textsc{P}}
\def\FP{\textsc{FP}}
\def\NP{\textsc{NP}}
\def\FNP{\textsc{FNP}}
\def\TFNP{\textsc{TFNP}}
\def\coNP{\textsc{coNP}}
\def\Banach{\textsc{NonMetricBanach}}
\def\Banachh{\textsc{Banach}}
\def\clocal{\textsc{Continuous LocalOpt}}

\newcommand{\reals}{\mathbb{R}}
\newcommand{\nats}{\mathbb{N}}

\def\OPT{\mathrm{OPT}}
\def\Int{\mathrm{Int}}
\def\Clos{\mathrm{Clos}}
\def\SC{\mathrm{SC}}
\def\MC{\mathrm{MC}}
\def\sw{\mathrm{sw}}
\def\mw{\mathrm{mw}}
\def\Ver{\mathrm{Ver}}
\def\ExpVer{\Exp\mathrm{Ver}}
\def\e{\epsilon}
\def\cost{\mathrm{cost}}

\def\norm#1{\left\|#1\right\|}
\def\normm#1{\left\|#1\right\|_{\Sigma}}
\def\abs#1{\left|#1\right|}
\def\matr#1{\mathbf{#1}}

\DeclareMathOperator*{\Min}{min}
\DeclareMathOperator*{\ver}{VER}
\newcommand{\correct}{\emph{correct}}
\newcommand{\wrong}{\emph{wrong}}
\renewcommand{\vec}{\mathbf}
\renewcommand{\l}{\vec{\lambda}}
\newcommand{\m}{\vec{\mu}}
\renewcommand{\v}{\vec{v}}
\newcommand{\diam}[2]{\mathrm{diam}_{#1}\left[ #2 \right]}

\definecolor{vergreen}{RGB}{0,85,2}
\definecolor{myvergreen}{RGB}{0,140,3}
\definecolor{provorange}{RGB}{85,34,0}
\definecolor{inputblue}{RGB}{5,13,111}
\definecolor{noapred}{RGB}{116,3,3}
\definecolor{classesblue}{RGB}{9,49,146}

\definecolor{secinhead}{RGB}{249,196,95}

\definecolor{lgray}{gray}{0.8}

 \coltauthor{\Name{Themis Gouleakis} \Email{tgoule@mit.edu}\\
 \addr EECS and CSAIL, MIT
 \AND
 \Name{Christos Tzamos} \Email{tzamos@mit.edu}\\
 \addr Microsoft Research
 \AND
 \Name{Manolis Zampetakis} \Email{mzampet@mit.edu}\\
 \addr EECS and CSAIL, MIT
 }

\begin{document}

\maketitle

\begin{abstract}
  A wide range of learning tasks require human input in labeling massive data.
  The collected data though are usually low quality and contain inaccuracies and
  errors. As a result, modern science and business face the problem of learning
  from unreliable data sets.

  In this work, we provide a generic approach that is based on
  \textit{verification} of only few records of the data set to guarantee high
  quality learning outcomes for various optimization objectives. Our method,
  identifies small sets of critical records and verifies their validity. We show
  that many problems only need $\poly(1/\eps)$ verifications, to ensure that the
  output of the computation is at most a factor of $(1 \pm \eps)$ away from the
  truth. For any given instance, we provide an \textit{instance optimal}
  solution that verifies the minimum possible number of records to approximately
  certify correctness. Then using this instance optimal formulation of the
  problem we prove our main result: ``every function that satisfies some
  Lipschitz continuity condition can be certified with a small number of
  verifications''. We show that the required Lipschitz continuity condition is
  satisfied even by some $\NP$-complete problems, which illustrates the
  generality and importance of this theorem.

  In case this certification step fails, an invalid record will be identified.
  Removing these records and repeating until success, guarantees that the result
  will be accurate and will depend only on the verified records. Surprisingly,
  as we show, for several computation tasks more efficient methods are possible.
  These methods always guarantee that the produced result is not affected by the
  invalid records, since any invalid record that affects the output will be
  detected and verified.
\end{abstract}

\begin{keywords}
  unreliable data set, verification, Lipschitz continuity
\end{keywords}

  \input{introduction.tex}

  \input{model.tex}

  \input{verification.tex}

  \input{instanceOpt.tex}

  \input{wcorrection.tex}

  \input{scorrection.tex}

  \section*{Acknowledgements}
  The authors were supported by NSF CCF-1551875, CCF-1617730, CCF-1733808, and
  IIS-1741137.

  \bibliography{ZAMPETAKIS18}

  \appendix
  \clearpage
  \input{appendix.tex}

\end{document}
